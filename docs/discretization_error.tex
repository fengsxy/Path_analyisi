\documentclass[11pt]{article}
\usepackage{amsmath, amssymb, amsfonts}
\usepackage{geometry}
\usepackage{graphicx}
\usepackage{hyperref}
\geometry{margin=1in}

\title{Discretization Error in the Stochastic-Localization SNR Parameterization}
\author{}
\date{}

\begin{document}
\maketitle

\section{Problem Setting}
We analyze the multi-scale diffusion model where each scale (e.g., \(64 \times 64\) and \(32 \times 32\)) is conditioned on a noisy latent produced by the SNR-based stochastic-localization form
\begin{equation}
    z = \mathrm{SNR} \cdot x_0 + \sqrt{\mathrm{SNR}} \cdot \epsilon,
    \qquad \epsilon \sim \mathcal{N}(0, I).
\end{equation}
The denoiser outputs \(\hat{x}(z)\), and we want to approximate the discretization error accumulated along a sampling path in the \((\mathrm{SNR}_{64}, \mathrm{SNR}_{32})\) plane. Following Align-Your-Steps, the local truncation error is measured via the Jacobian energy
\begin{equation}
    E(z) = v^\top (J \odot J) v,
    \qquad J = \frac{\partial \hat{x}}{\partial z},
\end{equation}
with \(v\) serving as a weighting tensor (we use uniform weights so \(E\) approximates \(\|J\|_F^2\)). Integrating \(E\) along a path yields the total discretization error.

\section{Chain-Rule Derivation}
The diffusion backbone internally operates on the DDIM state
\begin{equation}
    x_t = \alpha_t x_0 + \sigma_t \epsilon,
    \qquad \mathrm{SNR}_t = \frac{\alpha_t^2}{\sigma_t^2} = \frac{\alpha_t^2}{1 - \alpha_t^2}.
\end{equation}
Solving for \(\alpha_t^2\) gives \(\alpha_t^2 = \frac{\mathrm{SNR}}{1+\mathrm{SNR}}\). Eliminating \(x_t\) in terms of \(z\) yields
\begin{equation}
    z = \sqrt{\mathrm{SNR}(1+\mathrm{SNR})} \; x_t
    \quad \Rightarrow \quad
    x_t = \frac{z}{\sqrt{\mathrm{SNR}(1+\mathrm{SNR})}}.
\end{equation}
Therefore the Jacobian we obtain from the model is \(J_{x_t} = \partial \hat{x} / \partial x_t\). The desired Jacobian with respect to \(z\) is
\begin{equation}
    \frac{\partial \hat{x}}{\partial z}
    = \frac{\partial \hat{x}}{\partial x_t}
      \frac{\partial x_t}{\partial z}
    = J_{x_t} \cdot \frac{1}{\sqrt{\mathrm{SNR}(1+\mathrm{SNR})}}.
\end{equation}
Element-wise squaring gives
\begin{equation}
    J \odot J = \frac{J_{x_t} \odot J_{x_t}}{\mathrm{SNR}(1+\mathrm{SNR})}.
\end{equation}
Hence every Hutchinson estimate of \(v^\top(J \odot J)v\) must be multiplied by the chain-rule factor
\begin{equation}
    \boxed{
        \gamma(\mathrm{SNR}) = \frac{1}{\mathrm{SNR} \left(1+\mathrm{SNR}\right)}
    }.
\end{equation}
This factor enforces the theoretically expected decay \(E \propto \mathrm{SNR}^{-2}\) at high SNR, matching Greg Ver Steeg's observation.

\section{Numerical Estimation Algorithm}
\begin{enumerate}
    \item Draw a batch of clean images \(x_0\) and downsampled versions for the lower scale.
    \item For each scale, inject Gaussian noise corresponding to the desired SNR:
    \[
        x_{\text{noisy}} = \alpha x_0 + \sigma \epsilon,
        \quad \alpha = \sqrt{\frac{\mathrm{SNR}}{1+\mathrm{SNR}}}, \quad
        \sigma = \sqrt{1 - \alpha^2}.
    \]
    \item Define weighting tensors \(v\) (we use uniform weights normalized by spatial dimensions).
    \item Estimate \(H v = (J \odot J) v\) via Hutchinson probes:
    \begin{enumerate}
        \item Sample Rademacher probes \(u \in \{\pm 1\}\).
        \item Evaluate the JVP using automatic differentiation:
        \(\mathrm{JVP} = \nabla_z f(z) \cdot u\).
        \item Accumulate \(H v \approx \frac{1}{K} \sum_{k} \mathrm{JVP}_k^2\).
    \end{enumerate}
    \item Convert to scalar error with chain-rule correction:
    \[
        E = \gamma(\mathrm{SNR}) \cdot \frac{1}{B} \sum_{b} (v \odot H v)_b.
    \]
    \item Repeat for each SNR pair \((\mathrm{SNR}_0, \mathrm{SNR}_1)\) to build the error heatmap.
\end{enumerate}

\section{Multi-Scale Implementation}
For the LIFT Dual Timestep model with two scales, we compute separate errors:
\begin{itemize}
    \item \(E_0\): Error for scale 0 (\(64 \times 64\)), computed by varying \(z_0\) while fixing \(z_1\)
    \item \(E_1\): Error for scale 1 (\(32 \times 32\)), computed by varying \(z_1\) while fixing \(z_0\)
\end{itemize}

Each error is corrected by its respective chain-rule factor:
\begin{align}
    E_0 &= \gamma(\mathrm{SNR}_0) \cdot v^\top (J_0 \odot J_0) v, \\
    E_1 &= \gamma(\mathrm{SNR}_1) \cdot v^\top (J_1 \odot J_1) v.
\end{align}

The total error at each grid point is \(E_{\text{total}} = E_0 + E_1\).

\end{document}
